<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breathing Box Relaxation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #f0f9ff;
            /* sky-50 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            /* Prevent scrollbars */
            touch-action: none;
            /* Prevent standard touch actions for better app feel */
        }

        /* Custom range slider styling */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            background: transparent;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #60A5FA;
            cursor: pointer;
            margin-top: -8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #BFDBFE;
            border-radius: 2px;
        }

        input[type=range]:focus {
            outline: none;
        }

        #canvas-container {
            position: relative;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
            border-radius: 1.5rem;
            background: white;
            max-height: 95vh;
            overflow-y: auto;
            /* Allow scroll on very small screens if needed */
        }
    </style>
</head>

<body class="flex flex-col items-center justify-center h-screen w-screen p-4">

    <!-- Main Card -->
    <div id="canvas-container" class="flex flex-col items-center p-6 sm:p-8 w-full max-w-md">

        <h1 class="text-2xl font-light text-slate-700 mb-4 tracking-wide">4-7-8 Breathing</h1>

        <!-- The Canvas -->
        <canvas id="breathCanvas" width="300" height="300" class="mb-6"></canvas>

        <!-- Dynamic Text Indicator -->
        <div id="breathText"
            class="h-8 text-xl text-blue-500 font-medium tracking-wider mb-6 transition-opacity duration-300">
            Ready...
        </div>

        <!-- Controls -->
        <div class="w-full mb-4">
            <!-- Pattern Selector -->
            <div class="mb-4">
                <label for="patternSelect" class="block text-xs text-slate-400 uppercase tracking-wider mb-2">Breathing
                    Pattern</label>
                <select id="patternSelect"
                    class="w-full p-2 bg-slate-50 border border-slate-200 rounded-lg text-slate-600 text-sm focus:outline-none focus:ring-2 focus:ring-blue-100 transition-shadow">
                    <option value="4-7-8">4-7-8 Breathing</option>
                    <option value="4-4-4-4">Box Breathing (4-4-4-4)</option>
                </select>
            </div>
            <div class="flex justify-between text-sm text-slate-400 mb-2">
                <span>Faster</span>
                <span id="speedLabel">Standard (19s)</span>
                <span>Slower</span>
            </div>
            <!-- Range updated for 4-7-8 cycle (usually 19s total) -->
            <input type="range" id="speedSlider" min="10" max="30" step="1" value="19" class="w-full mb-4"
                aria-label="Breathing Speed">

            <div class="flex items-center justify-between mb-4">
                <!-- Sound Toggle -->
                <div class="flex items-center space-x-2">
                    <input type="checkbox" id="soundToggle" checked
                        class="w-4 h-4 text-blue-600 rounded focus:ring-blue-500 border-gray-300">
                    <label for="soundToggle" class="text-sm text-slate-500">Enable Audio Cues</label>
                </div>
            </div>

            <!-- Pause Button -->
            <button id="pauseBtn"
                class="w-full py-3 bg-blue-50 hover:bg-blue-100 text-blue-600 rounded-xl font-medium transition-colors flex items-center justify-center space-x-2">
                <svg id="pauseIcon" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20"
                    fill="currentColor">
                    <path fill-rule="evenodd"
                        d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z"
                        clip-rule="evenodd" />
                </svg>
                <span id="pauseText">Pause</span>
            </button>
        </div>

        <!-- Session Timer Section -->
        <div class="w-full pt-4 border-t border-slate-100 flex flex-col items-center">
            <span class="text-xs text-slate-400 uppercase tracking-wider mb-1">Session Duration</span>
            <div id="sessionTimer" class="text-3xl font-light text-slate-600 font-mono mb-2">00:00</div>
            <button id="resetTimerBtn"
                class="text-xs text-blue-400 hover:text-blue-600 transition-colors underline decoration-dotted">
                Reset Timer
            </button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('breathCanvas');
        const ctx = canvas.getContext('2d');
        const slider = document.getElementById('speedSlider');
        const speedLabel = document.getElementById('speedLabel');
        const breathText = document.getElementById('breathText');
        const soundToggle = document.getElementById('soundToggle');
        const sessionTimerDisplay = document.getElementById('sessionTimer');
        const resetTimerBtn = document.getElementById('resetTimerBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const pauseText = document.getElementById('pauseText');
        const patternSelect = document.getElementById('patternSelect');

        // Audio Context Setup
        let audioCtx;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        soundToggle.addEventListener('change', () => {
            if (soundToggle.checked) {
                initAudio();
            }
        });

        // DISTINCT AUDIO CUES
        function playPhaseCue(phaseIndex) {
            if (!soundToggle.checked || !audioCtx) return;

            // Resume if suspended
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const now = audioCtx.currentTime;
            let stopTime = now;

            const type = patterns[currentPattern].types[phaseIndex];

            if (type === 'inhale') {
                // INHALE: Bright Chime (C5)
                osc.type = 'sine';
                osc.frequency.setValueAtTime(523.25, now);

                // Envelope: Smooth attack, long decay
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 2.5);
                stopTime = now + 2.5;

            } else if (type === 'hold-full' || type === 'hold-empty') {
                // HOLD: Gentle Pulse / Soft Bell (E4)
                osc.type = 'sine';
                osc.frequency.setValueAtTime(329.63, now);

                // Envelope: Softer attack, longer decay
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.15, now + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
                stopTime = now + 1.5;

            } else if (type === 'exhale') {
                // EXHALE: Deep Grounding Bowl (G3)
                osc.type = 'sine';
                osc.frequency.setValueAtTime(196.00, now);

                // Envelope: Slow attack, very long decay
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.2, now + 0.5);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 3.5);
                stopTime = now + 3.5;
            } else {
                return;
            }

            osc.connect(gain);
            gain.connect(audioCtx.destination);

            osc.start(now);
            osc.stop(stopTime);
        }

        // Animation State
        let startTime = 0;
        // Session Timer State
        let sessionStartTime = 0;
        // Pause State
        let isPaused = true;
        let isFirstStart = true;
        let pauseStart = 0;

        // Breathing Patterns Configuration
        const patterns = {
            "4-7-8": {
                phases: [4, 7, 8],
                types: ['inhale', 'hold-full', 'exhale'],
                defaultDuration: 19
            },
            "4-4-4-4": {
                phases: [4, 4, 4, 4],
                types: ['inhale', 'hold-full', 'exhale', 'hold-empty'],
                defaultDuration: 16
            }
        };
        let currentPattern = "4-7-8";

        // Standard 4-7-8 is 19 seconds total
        let duration = 19000;
        const baseSize = 100; // Smallest size
        const growthAmount = 100; // How much it grows

        // Phase tracking for audio
        let lastPhase = -1;

        // Colors
        const boxColor = 'rgba(96, 165, 250, 0.8)'; // Tailwind blue-400
        const glowColor = 'rgba(147, 197, 253, 0.4)'; // Tailwind blue-300
        const textColor = 'rgba(255, 255, 255, 0.95)'; // White text for inside box

        // Handle Slider Input
        slider.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            duration = val * 1000;
            startTime = Date.now() + 3000; // Reset with countdown
            lastPhase = -1; // Reset audio trigger

            const defaultDur = patterns[currentPattern].defaultDuration;
            speedLabel.textContent = val === defaultDur ? `Standard (${val}s)` : `${val}s Cycle`;

            // Only auto-resume if we have already started
            if (isPaused && !isFirstStart) togglePause();
        });

        // Handle Pattern Change
        patternSelect.addEventListener('change', (e) => {
            currentPattern = e.target.value;
            const config = patterns[currentPattern];

            // Update duration to the pattern's default
            duration = config.defaultDuration * 1000;
            slider.value = config.defaultDuration;

            // Update Speed Label
            speedLabel.textContent = `Standard (${config.defaultDuration}s)`;

            // Update Title
            document.querySelector('h1').textContent = patternSelect.options[patternSelect.selectedIndex].text;

            // Reset State
            if (!isFirstStart) {
                startTime = Date.now() + 3000;
                lastPhase = -1;
                if (isPaused) togglePause();
            }
        });

        // Handle Session Timer Reset
        resetTimerBtn.addEventListener('click', () => {
            sessionStartTime = Date.now();
            if (isPaused) {
                // If paused, we adjust session start time so that "00:00" is displayed but it doesn't tick up
                // Logic: effective start time = Now - (elapsed previously). If elapsed is 0, start time is now.
                // We also need to reset pauseStart to Now so the delta is 0 when we eventually resume.
                pauseStart = Date.now();
            }
            sessionTimerDisplay.textContent = "00:00";
        });

        // Handle Pause/Start
        function togglePause() {
            if (isFirstStart) {
                // FIRST START LOGIC
                try {
                    initAudio();
                } catch (e) {
                    console.error("Audio init failed", e);
                }
                isFirstStart = false;
                isPaused = false;

                // Start with countdown
                startTime = Date.now() + 3000;
                sessionStartTime = Date.now() + 3000;

                // Update UI to Pause state
                pauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg> <span id="pauseText">Pause</span>`;

                draw();
                return;
            }

            isPaused = !isPaused;
            if (isPaused) {
                // SVG Icon to Play
                pauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg> <span id="pauseText">Resume</span>`;
                pauseStart = Date.now();
            } else {
                // SVG Icon to Pause
                pauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg> <span id="pauseText">Pause</span>`;

                // Calculate how long we were paused
                const now = Date.now();
                const pausedDuration = now - pauseStart;

                // Shift start times forward so the animation continues smoothly
                startTime += pausedDuration;
                sessionStartTime += pausedDuration;

                // Restart Loop
                draw();
            }
        }

        pauseBtn.addEventListener('click', togglePause);

        function resetToStart() {
            isPaused = true;
            isFirstStart = true;

            // Set Button to "Start Session"
            pauseBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" /></svg> <span id="pauseText">Start Session</span>`;

            // Draw Initial State
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw Static Box
            const center = canvas.width / 2;
            const offset = baseSize / 2;
            const x = center - offset;
            const y = center - offset;
            const width = baseSize;
            const height = baseSize;
            const radius = 20;

            // Glow
            ctx.shadowBlur = 20;
            ctx.shadowColor = glowColor;

            // Box
            ctx.fillStyle = boxColor;
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill();

            // Text
            breathText.textContent = "Ready";
            breathText.style.opacity = 1;

            // Inner Text
            ctx.font = "bold 32px 'Segoe UI', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = textColor;
            ctx.fillText("Start", center, center);

            ctx.shadowBlur = 0;
        }

        function easeInOutSine(x) {
            return -(Math.cos(Math.PI * x) - 1) / 2;
        }

        function updateSessionTimer() {
            // If paused, we don't update the display, it stays at the value when paused
            if (isPaused) return;

            const now = Date.now();
            // Clamp to 0 if in countdown (negative)
            const totalSeconds = Math.max(0, Math.floor((now - sessionStartTime) / 1000));
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            sessionTimerDisplay.textContent = `${minutes}:${seconds}`;
        }

        function draw() {
            if (isPaused) return; // Stop the loop if paused

            // Update Timer every frame
            updateSessionTimer();

            // Calculate time elapsed
            const now = Date.now();
            const elapsed = now - startTime;

            // Clear Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let currentSizeRatio = 0;
            let currentText = "";
            let currentOpacity = 1;
            let rotationAngle = 0;
            let countdown = 0;
            let currentPhase = -1;

            if (elapsed < 0) {
                // COUNTDOWN PHASE
                currentText = "Get Ready...";
                currentSizeRatio = 0; // Start empty
                currentOpacity = 1;

                // Calculate countdown (3, 2, 1)
                countdown = Math.ceil(-elapsed / 1000);

                // Pulse effect for countdown numbers
                const pulseProgress = (-elapsed % 1000) / 1000;
                // Scale text slightly
                // We'll handle text scaling in the draw section if needed, 
                // but for now just static size is fine or simple opacity pulse
                currentOpacity = 0.5 + (pulseProgress * 0.5);

            } else {
                // BREATHING PHASE
                const cycleTime = elapsed % duration; // Time within current cycle in ms
                const cycleProgress = cycleTime / duration;

                // Get Current Pattern Config
                const config = patterns[currentPattern];
                const totalUnits = config.phases.reduce((a, b) => a + b, 0);

                // Calculate Ratios
                let accumulatedRatio = 0;

                for (let i = 0; i < config.phases.length; i++) {
                    const phaseUnits = config.phases[i];
                    const phaseRatio = phaseUnits / totalUnits;
                    const phaseStart = accumulatedRatio;
                    const phaseEnd = accumulatedRatio + phaseRatio;

                    if (cycleProgress < phaseEnd) {
                        currentPhase = i;
                        const type = config.types[i];

                        // Normalize progress 0->1 for this specific phase
                        const phaseProgress = (cycleProgress - (phaseStart * duration)) / (phaseRatio * duration);
                        const p = Math.max(0, Math.min(1, phaseProgress));

                        // Countdown logic
                        const msPhaseEnd = duration * phaseEnd;
                        countdown = Math.ceil((msPhaseEnd - cycleTime) / 1000);

                        if (type === 'inhale') {
                            currentText = "Breathe In";
                            currentSizeRatio = easeInOutSine(p);
                            currentOpacity = 1;
                        } else if (type === 'hold-full') {
                            currentText = "Hold";
                            currentSizeRatio = 1;
                            currentSizeRatio += Math.sin(p * Math.PI * 2) * 0.02;
                            rotationAngle = Math.sin(p * Math.PI * 8) * 0.03;
                            currentOpacity = 0.9;
                        } else if (type === 'exhale') {
                            currentText = "Breathe Out";
                            currentSizeRatio = 1 - easeInOutSine(p);
                            currentOpacity = 0.8;
                        } else if (type === 'hold-empty') {
                            currentText = "Hold";
                            currentSizeRatio = 0;
                            currentSizeRatio += Math.sin(p * Math.PI * 2) * 0.01;
                            currentOpacity = 0.7;
                        }

                        break;
                    }
                    accumulatedRatio += phaseRatio;
                }
            }

            // Audio Trigger Logic
            // Only play audio if we are in a valid phase (>= 0)
            if (currentPhase !== -1 && currentPhase !== lastPhase) {
                playPhaseCue(currentPhase);
                lastPhase = currentPhase;
            } else if (currentPhase === -1) {
                // Reset lastPhase during countdown so first inhale triggers
                lastPhase = -1;
            }

            // Update Text (label outside box)
            breathText.textContent = currentText;
            breathText.style.opacity = currentOpacity;

            // Calculate current square size
            const currentSize = baseSize + (currentSizeRatio * growthAmount);
            const center = canvas.width / 2;
            const offset = currentSize / 2;

            // Apply Rotation
            ctx.save();
            ctx.translate(center, center);
            ctx.rotate(rotationAngle);
            ctx.translate(-center, -center);

            // Draw Glow (Outer Shadow)
            ctx.shadowBlur = 20 + (currentSizeRatio * 15);
            ctx.shadowColor = glowColor;

            // Draw Box
            ctx.fillStyle = boxColor;

            // Rounded Rectangle Logic
            const x = center - offset;
            const y = center - offset;
            const width = currentSize;
            const height = currentSize;
            const radius = 20; // Corner radius

            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();

            ctx.fill();

            // Draw Countdown Number inside the box
            ctx.font = "bold 48px 'Segoe UI', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = textColor;
            ctx.fillText(countdown, center, center);

            // Restore context to undo rotation for next frame
            ctx.restore();

            // Reset shadow for next frame (performance)
            ctx.shadowBlur = 0;

            requestAnimationFrame(draw);
        }

        // Initialize
        resetToStart();

    </script>
</body>

</html>